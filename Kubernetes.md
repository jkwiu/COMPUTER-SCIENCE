1. Docker
   1. Host OS를 공유한다는데 이는 정확히 말하면 OS가 아니라 Kernel을 공유하는 것이다. 도커에서 pull하는 image는 사실 진짜 iso이미지가 아니고 union file system, cgroup, namespace가 그렇게 보이게 해주는 것이다. 이것들은 커널을 공유히지만 각 컨테이너들을 격리시켜준다.
2. POD
   1. 쿠버네티스가 하나 또는 그 이상의 컨테이너를 관리하는 데 사용하는 단위다.
   2. 파드는 쿠버네티스에서 컴퓨팅의 최소 단위다.
   3. 컨테이너는 애플리케이션 구성 요소 하나를 실행하는 가상화된 환경이다.
   4. 쿠버네티스는 이 컨테이너를 또 다른 가상환경인 파드로 감싼다.
   5. 파드는 컴퓨팅의 단위로 클러스터를 이루는 노드 중 하나에서 실행된다.
   6. 파드는 쿠버네티스로 관리되는 자신만의 가상 IP주소를 가지며 이 주소로 가상 네트워크에 접속된 다른 파드, 심지어 다른 노드에서 실행되는 파드라도 통신을 주고 받을 수 있다.
   7. 파드 하나는 대개 컨테이너 하나를 포함하는데, 설정에 따라 파드 하나가 여러개의 컨테이너를 포함할 수 있다.
   8. 파드에 포함된 모든 컨테이너는 같은 가상 환경에 포함되므로 네트워크를 공유하며 localhost로 서로 통신도 할 수 있다.
   9. 파드는 쿠버네티스가 관리하는 리소스다.
   10. 쿠버네티스가 컨테이너를 직접 실행하지 않고 컨테이너를 생성할 책임을 해당 노드에 설치된 컨테이너 런타임에 맡기는 형태다. 컨테이너는 도커가 될 수 있고 다른 것도 될 수 있다. 컨테이너가 곧 도커다는 아니라는 말이구나.
   11. 파드는 파드를 생성할 때 한 노드에 배정된다. 이 파드를 관리하고 파드에 포함된 컨테이너를 실행되는 책임도 이 노드가 맡는다. 이 과정은 컨테이너 런타임 인터페이스(CRI)라는 공통 API를 이용하여 컨테이너 런타임과 연동되는 형태로 진행된다.
       1.  런타임이란 프로그램이 실행될 때 필요한 환경 및 시스템 자원을 말한다. 이는 운영체제, 하드웨어, 네트워크, 파일시스템 등의 요소를 포함한다.
   12. 보다 더 이해하기 위하여
       1.  파드로 실행된 컨테이너가 있다.
       2.  ``docker 명령어로 해당 커맨드로 이 컨테이너를 삭제해도 다시 파드를 확인해보면 다른 컨테이너id로 돌아가고 있다.``
       3.  쿠버네티스는 이처럼 self-healing(자기수복성)을 가진다.
       4.  쿠버네티스는 컨테이너를 파드로 추상화했기 때문에 이를 해결할 수 있다.
       5.  이상을 일으킨 컨테이너는 내리고 새로운 컨테이너를 추가할 뿐이다.
   13. 네트워크 트래픽을 노드에서 파드로 전달할 수 있다. 이 기능을 통해서 클라스터 외부에서 파드와 통신할 수 있다.
3.  컨트롤러 객체
    1.  다른 리소스를 관리하는 쿠버네티스 리소스다.
    2.  여러가지 컨트롤러 객체가 있지만 그중에서 ``파드를 관리하는 컨트롤러 객체``가 ``디플로이먼트``다
    3.  디플로이먼트
        1.  레이블(label)을 통해 ``key:value``쌍으로 리소스간의 관계를 파악한다. 즉 ``파드``를 ``관리``d한다.
        2.  레이블을 함부로 수정하면 파드가 디플로이먼트의 관리를 벗어난다.
            1.  이를 이용하여 문제가 발생한 파드를 디버그할 수 있다.
            2.  기존 파드의 레이블을 수정하면 관리에서 벗어나고 디플로이먼트는 새로운 파드를 생성한다.
            3.  그러면 파드가 두개 생긴다. 디플로이먼트는 새로 생긴 파드를 관리한다.
            4.  기존의 파드를 디버그한 뒤, 다시 레이블을 원래대로 수정하면 디플로이먼트는 다시 이 파드를 관리한다. 새로 생겼던 파드는 디플로이먼트가 파드 1개만 필요하므로 사라진다.
        3. 애플리케이션 매니페스트
           1. JSON, YAML로 작성할 수 있고 보통 가독성이 뛰어나고 파일 하나에 더 많은 리소스를 정의할 수 있는 YAML을 많이 쓴다.
           2. YAML이 있으면 어디에도 동일한 배포가 가능하다.
           3. YAML파일이 굳이 로컬에 없어도 원격에 있는 매니페스트 파일로 배포할 수 있다.
        4. POD에서 실행 중인 애플리케이션에 접근할 수 있다.
        5. POD에서 실행 중인 애플리케이션의 로그를 볼 수 있다.
        6. POD에서 실행 중인 애플리케이션의 컨테이너와 로컬 컴퓨터 사이에 파일 복사하기도 가능하다.
    4. ``컨트롤러 객체가 관리하는 리소스를 삭제하려면 해당 컨트롤러 객체를 삭제해야 한다.``
 4. 쿠버네티스에서는 서비스에 ``address recovery``를 적용하여 파드가 새로 생성될 때마다 바뀌는 ip로 인해 파드를 찾아가지 못하는 것을 해결했다. 쿠버네티스 DNS 서버에서 서로의 파드끼리 ip가 바뀌어도 통신할 수 있다.
    1. 서비스가 생성되면 서비스의 ip주소가 클러스터 내 DNS서버에 등록되고, 이 IP주소는 정적주소로 서비스가 삭제될 때까지 변경되지 않는다.
    2. 쿠버네티스 DNS 서버에서 도메인 네임에 따른 서비스의 ip를 반환한다.
    3. 파드가 서비스를 가져야 도메인 네임으로 접근할 수 있다. 디플로이먼트와 같이 레이블 셀렉터를 이용한 방식으로 파드와 느슨한 연결을 갖는 것과 같다.
 5. 로드 밸런서
    1. 클러스터 외부에서 들어오는 트래픽을 파드에 전달해준다.
    2. 로드밸런서 서비스의 커버 범위는 클러스터 전체다.
    3. 클러스터 외부로 트래픽을 전달해줄 수도 있다.
 6. 쿠버네티스는 ``쿠버네티스 프록시``와 ``쿠버네티스 DNS서버``를 이용해서 서로를 찾아낸다.
    1. 클러스터IP는 네트워크상에 실재하지 않는 가상 IP주소다. 파드는 각 노드마다 동작하는 네트워크 프록시를 경유하여 네트워크에 접근한다. 그리고 이 프록시는 패킷 필터링을 적용하여 가상 IP주소를 실제 엔드포인트로 연결한다.
    2. 클라이언트는 가상 정적 IP와 네트워크 프록시만 있으면 항상 최신 상태의 엔드포인트 목록을 적용받는다.
    3. 쿠버네티스 DNS서버는 엔드포인트 IP주소가 아닌 클러스터의 IP주소를 반환한다. 엔드포인트가 가리키는 IP주소는 계속 변화하기 때문이다.
    4. 모든 쿠버네티스 리소스는 ``네임스페이스``안에 존재한다. 네임스페이스는 다른 리소스를 하나로 묶기 위한 리로스다. 이것은 쿠버네티스 클러스터를 논리적 파티션으로 분할하는 역할을 한다.
 7. 애플리케이션 설정
    1. ``컨피그맵``과 ``비밀값``을 이용한다.
       1. 이 둘은 클러스터 속에서 다른 리소스와 독립적인 장소에 보관
    2. 컨피그맵(ConfigMap)
       1. 환경변수는 파드의 생애 주기 내내 변하지 않는다. 교체하기 위해서는 파드를 교체해야 한다.
       2. 컨피그맵에 저장한 파일을 불러와 설정값을 애플리케이션에 주입할 수 있다. 컨피그맵은 파드에서 읽어 들이는 데이터를 저장하는 리소스다. 데이터의 형태는 ``JSON, XML, YAML 등`` 다양하다.
       3. 환경 변수 이름이 중복될 경우 ``envFrom``항목에서 우선순위를 정할 수 있다. 기본적으로 ``logging``을 ``warning``으로 하고 개별 컨테이너마다 각각 다른 레벨의 로그를 적용하는 것도 가능하다.
       4. 환경변수 외에 컨테이너 파일 시스템 속 파일로 설정값을 주입할 수도 있다. 아래의 두가지 기능을 이용한다. 포인트는 설정값을 ``디렉토리의 마운트형태``로 옮겨서 바꾼다는 것이다.
          1. 컨피그맵에 담긴 데이터를 파드로 전달하는 ``볼륨``
          2. 컨피그맵을 읽어 들인 볼륨을 파드 컨테이너의 특정 경로에 위치시키는 ``볼륨마운트``
       5. 이 방법은 파드의 교체없이 설정이 바로 반영되지만, 그를 요구하지 않는 애플리케이션에서는 사용이 제한된다. 애플리케이션의 재시작없이 설정값을 변경해야 한다면 유용하다.
    3. 비밀값(Secret)
       1. 클러스터 내부에서 별도로 관리된다. 해당 비밀값을 사용하는 노드에만 전달되며, 노드에서도 디스크가 아닌 메모리에만 담긴다. 전달과정과 저장할 때 암호화가 적용된다.
       2. 실제 서비스 운영에서 운영환경의 민감한 데이터를 YAML에 포함시켜서는 안된다. 그 자리를 표시해두고 ``애저 키볼트``나 ``깃허브 시크릿 기능``을 이용하여 애플리케이션을 배치할 때 추가적인 처리를 거치는 방법을 쓴다.
    4. 운영팁
       1. 설계단계에서의 염두할 점
          1. 애플리케이션의 중단 없이 설정 변경에 대응이 필요한가?
          2. 민감 정보를 어떻게 관리할 것인가?
 8. 데이터 퍼시스턴시
    1. 쿠버네티스 환경에서 문제가 생긴 노드가 있다면 이 노드에서 동작하던 파드를 다른 노드에 새로 생성해주면 된다. 하지만 고장난 노드에 있던 파드에 데이터가 저장되어 있었다면 이 데이터는 유실된다. 그렇기 때문에 클러스터 전체에서 접근할 수 있는 저장소, 어떤 노드에 있는 파드라도 동일하게 데이터에 접근할 수 있는 저장소는 반드시 필요하다.
    2. 쿠버네티스에서 컨테이너 파일 시스템이 구축되는 과정
       1. 파드 속 파일 시스템은 여러가지 레이어가 쌓여 구성된다. 
          1. 컨테이너 이미지
             1. 파일 시스템의 초기내용을 제공
             2. ``도커 이미지는 읽기 전용이다.``
          2. 컨테이너가 기록 가능한 레이어(writable layer)
             1. 컨테이너 레이어 위에 쌓이며 이미지에 들어있던 파일을 수정하거나 새로운 파일을 기록하는 작업이 여기서 일어난다.
    3. ``생애주기(lifecycle)``
       1. 생애주기를 정확히 이해하여야 서비스 구축과 운영과정에서 혼동이 없다. 반드시 알아두자.
       2. ``파드 속 컨테이너의 생애주기는 해당 컨테이너의 생애주기를 따른다. 또한 파드의 재시작은 그 안에 들어있는 컨테이너의 재시작이다.``
          1. 파드에서 동작하던 애플리케이션이 열심히 데이터를 기록했고, 이 데이터가 ``파드수준``에서 저장되지 않은 상태에서 파드가 컨테이너를 재시작하면 이 데이터는 유실된다.
       3. 공디렉토리(EmptyDir) 트릭
          1. 컨테이너 안에서 빈 디렉토리로 초기화되는 유형의 볼륨인 공디렉토리를 사용하는 파드의 정의다.
          2. ``공디렉토리는 파드 수준의 스토리지``다
          3. ``파드의 생애주기``를 가지므로 파드가 재시작해도 공디렉토리 볼륨에 저장된 데이터는 유지된다.
          4. ``캐시``를 사용할 때 유용하게 사용될 수 있을 것 같다.(내 생각)
             1. ``임시 저장 목적``에 유용하다.
             2. 어떤 애플리케이션 API응답이 상당 시간동안 유효하다면, API를 반복 호출하기보다 전에 호출했던 응답을 파일로 지정해 두는 것이 빠르다. 공디렉토리 볼륨은 이런 목적의 ``로컬캐시``에 적합하다. 애플리케이션이 죽더라도 대체 컨테이너가 그대로 이 데이터를 이어 받아 캐시 효과를 볼 수 있기 때문이다.
          5. 파드와 생애주기를 함께하므로, ``파드가 대체되어 새 파드를 만들면 처음 상태의 빈 디렉토리가 된다.``